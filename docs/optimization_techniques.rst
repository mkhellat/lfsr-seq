Optimization Techniques
=======================

This section provides a comprehensive introduction to the optimization techniques
available in lfsr-seq. These techniques significantly improve performance for
structured problems and enable analysis of larger LFSRs. The documentation is
designed to be accessible to beginners while providing sufficient depth for
researchers and developers.

Introduction
------------

**What are Optimization Techniques?**

Optimization techniques are methods that improve the efficiency of computations
by exploiting mathematical structure, caching results, and detecting special cases.
In the context of LFSR analysis, optimization techniques can provide 10-100x
speedup for certain problems.

**Why are Optimization Techniques Important?**

1. **Performance**: Enable analysis of larger LFSRs (degree > 20) that would
   otherwise be infeasible

2. **Efficiency**: Reduce computation time for repeated analyses through caching

3. **Scalability**: Allow the tool to handle real-world problems with practical
   execution times

4. **Research Value**: Enable researchers to analyze larger systems and explore
   more configurations

**When are Optimization Techniques Applicable?**

Optimization techniques are most beneficial when:
- Analyzing large LFSRs (degree > 15)
- Repeatedly analyzing the same LFSR configuration
- Working with structured problems (primitive polynomials, known factorizations)
- Batch processing multiple LFSR configurations

Key Concepts
------------

Period Computation via Factorization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**What is Period Computation via Factorization?**

Instead of enumerating all states in the state space (which is O(q^d) where q
is field order and d is degree), we can compute the period by factoring the
characteristic polynomial and computing the LCM of the orders of irreducible
factors.

**Key Terminology**:

- **Polynomial Factorization**: The process of decomposing a polynomial into
  irreducible factors (factors that cannot be factored further over the field).
  For example, over GF(2), t^4 + t + 1 is irreducible, but t^4 + 1 factors as
  (t+1)^4.

- **Irreducible Factor**: A polynomial that cannot be factored into polynomials
  of lower degree over the given field. Irreducible polynomials are the
  "building blocks" of polynomial factorization, similar to prime numbers in
  integer factorization.

- **Order of a Polynomial**: The smallest positive integer n such that t^n ≡ 1
  (mod P(t)) over the field. The order determines the period of sequences
  generated by the polynomial.

- **LCM (Least Common Multiple)**: The smallest positive integer that is
  divisible by all given integers. For example, LCM(4, 6) = 12, LCM(3, 5, 7) = 105.
  The LCM is used to combine periods from different factors.

- **Characteristic Polynomial**: The polynomial P(t) = det(tI - C) where C is
  the state update matrix. The order of this polynomial equals the maximum
  period of the LFSR.

**Mathematical Foundation**:

If the characteristic polynomial factors as:

.. math::

   P(t) = \prod_{i=1}^{k} f_i(t)^{e_i}

where :math:`f_i(t)` are irreducible factors and :math:`e_i` are their
multiplicities, then the period is:

.. math::

   \text{period} = \text{lcm}(\text{ord}(f_1(t)), \ldots, \text{ord}(f_k(t)))

where :math:`\text{ord}(f_i(t))` is the order of the irreducible factor.

**Algorithm**:

1. Build the characteristic polynomial from LFSR coefficients
2. Factor the polynomial into irreducible factors
3. For each irreducible factor, compute its order
4. Compute the LCM of all factor orders
5. Return the LCM as the period

**Advantages**:

- Much faster than enumeration for large LFSRs (degree > 15)
- Works efficiently even when state space is huge (e.g., 2^32 states)
- Provides theoretical insight into period structure
- Can handle cases where enumeration would be infeasible

**Limitations**:

- Factorization can be expensive for very high-degree polynomials
- May not be faster than enumeration for small degrees (< 10) due to overhead
- Requires polynomial factorization algorithms (provided by SageMath)

**Example**:

Consider an LFSR with coefficients [1, 0, 0, 1] over GF(2). The characteristic
polynomial is t^4 + t + 1, which is irreducible. Its order is 15, so the period
is 15. This can be computed via factorization without enumerating all 16 states.

Result Caching System
~~~~~~~~~~~~~~~~~~~~~

**What is Result Caching?**

Result caching stores computed results so they can be reused without
recomputation. This is particularly valuable when analyzing the same LFSR
configuration multiple times or when processing batches of similar LFSRs.

**Key Terminology**:

- **Cache**: A storage mechanism for computed results to avoid redundant
  calculations. Think of it as a "memory" that remembers previous computations.

- **Cache Key**: A unique identifier for a computation. In our case, it's a
  hash of the LFSR configuration (coefficients and field order). Identical
  configurations produce identical keys.

- **Cache Hit**: When a requested result is found in the cache, avoiding the
  need to recompute it. This is the desired outcome that saves computation time.

- **Cache Miss**: When a requested result is not in the cache, requiring
  computation. After computation, the result is stored in the cache for future
  use.

- **Cache Invalidation**: Removing stale or incorrect entries from the cache.
  This is important when algorithms change or bugs are fixed, as old cached
  results may no longer be valid.

- **Persistent Cache**: A cache that survives between program runs, stored on
  disk (typically as a JSON file). This allows results to be reused across
  different sessions, even after the program exits.

- **In-Memory Cache**: A cache stored in RAM that is fast but lost when the
  program exits. Used for temporary results within a single session.

- **Hash Function**: A function that maps data of arbitrary size to fixed-size
  values (hashes). We use SHA-256 to generate cache keys, ensuring that
  identical configurations produce identical keys.

**Cache Strategy**:

The cache uses a two-level approach:

1. **In-Memory Cache**: Fast dictionary-based storage for current session
2. **Persistent Cache**: File-based storage for cross-session reuse

**Cache Key Generation**:

Cache keys are generated by hashing the LFSR configuration:
- Coefficients (normalized to remove trailing zeros)
- Field order
- Analysis type (period, polynomial, etc.)

This ensures that identical LFSR configurations produce the same key, enabling
cache hits.

**Cache Statistics**:

The cache tracks statistics to monitor effectiveness:
- **Hits**: Number of successful cache lookups
- **Misses**: Number of cache lookups that required computation
- **Hit Rate**: Ratio of hits to total requests (hits / (hits + misses))
- **Sets**: Number of values stored in cache

**Example**:

.. code-block:: python

   from lfsr.optimization import ResultCache
   
   # Create cache with persistent storage
   cache = ResultCache(cache_file="~/.lfsr-seq/cache.json")
   
   # Generate cache key
   key = cache.generate_key([1, 0, 0, 1], 2, "period")
   
   # Check cache
   if key in cache:
       period = cache.get(key)
       print(f"Cached period: {period}")
   else:
       # Compute period (expensive operation)
       period = compute_period([1, 0, 0, 1], 2)
       cache.set(key, period)
       print(f"Computed period: {period}")

Mathematical Shortcut Detection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**What is Mathematical Shortcut Detection?**

Mathematical shortcut detection identifies special cases that allow for optimized
computation. Instead of using general-purpose algorithms, we can use specialized
algorithms that are much faster for these special cases.

**Key Terminology**:

- **Mathematical Shortcut**: An optimized algorithm for a special case that
  avoids expensive general-purpose computation. For example, if we know a
  polynomial is primitive, we immediately know its period without computation.

- **Primitive Polynomial Shortcut**: When a polynomial is primitive, the period
  is immediately known to be q^d - 1 (where q is field order and d is degree)
  without any computation. This is an O(1) operation.

- **Irreducible Polynomial Shortcut**: When a polynomial is irreducible (but
  not necessarily primitive), factorization-based period computation is
  particularly efficient because there's only one factor to consider.

- **Small Degree Shortcut**: For very small degrees (e.g., d ≤ 10), enumeration
  may be faster than factorization due to the overhead of factorization
  algorithms. The tool automatically selects the faster method.

- **Pattern Recognition**: Detecting known polynomial patterns that have known
  properties. For example, trinomials (polynomials with exactly 3 non-zero
  terms) and pentanomials (5 non-zero terms) have special properties that can
  be exploited.

**Special Cases Detected**:

1. **Primitive Polynomials**: 
   - Period = q^d - 1 (maximum period)
   - Complexity: O(1) - no computation needed
   - Example: t^4 + t + 1 over GF(2) is primitive, period = 15

2. **Irreducible Polynomials**:
   - Can use factorization directly (only one factor)
   - Complexity: O(d^3) - factorization complexity
   - Example: t^4 + t^3 + t^2 + t + 1 over GF(2) is irreducible

3. **Small Degrees**:
   - Enumeration may be faster than factorization
   - Complexity: O(2^d) but with small constant factor
   - Example: Degree 4-10 over GF(2)

4. **Known Patterns**:
   - Trinomials: Polynomials with exactly 3 non-zero terms
   - Pentanomials: Polynomials with exactly 5 non-zero terms
   - These patterns have special properties that can be exploited

**Algorithm Selection**:

The tool automatically selects the optimal algorithm based on detected shortcuts:

- **Primitive**: Use primitive shortcut (O(1))
- **Irreducible**: Use factorization (O(d^3))
- **Small degree**: Use enumeration (O(2^d) with small constant)
- **Large degree**: Use factorization (O(d^3) + order computation)
- **Default**: Use enumeration (O(2^d))

**Example**:

.. code-block:: python

   from lfsr.polynomial import detect_mathematical_shortcuts
   
   shortcuts = detect_mathematical_shortcuts([1, 0, 0, 1], 2)
   
   if shortcuts['is_primitive']:
       print(f"Primitive polynomial! Period = {shortcuts['expected_period']}")
       print(f"Using: {shortcuts['recommended_method']}")
   else:
       print(f"Using: {shortcuts['recommended_method']}")
       print(f"Complexity: {shortcuts['complexity_estimate']}")

Performance Improvements
------------------------

**Expected Speedups**:

- **Primitive Polynomials**: 10^6 - 10^9x faster (O(1) vs O(2^d))
- **Factorization vs Enumeration**: 10-100x faster for degree > 15
- **Caching**: Instant for repeated analyses (cache hit)
- **Overall**: 10-100x speedup for structured problems

**When to Use Each Technique**:

- **Period via Factorization**: Use for degree > 15 or when enumeration is slow
- **Caching**: Always use for repeated analyses or batch processing
- **Shortcut Detection**: Automatic - tool selects optimal method

**Benchmarking**:

The tool includes benchmarking capabilities to measure performance improvements.
See the examples section for benchmarking examples.

API Reference
-------------

The optimization techniques are implemented in:

- :mod:`lfsr.polynomial` - Period computation via factorization, shortcut detection
- :mod:`lfsr.optimization` - Result caching system

See :doc:`api/polynomial` and :doc:`api/optimization` for complete API documentation.

Command-Line Usage
------------------

Optimization techniques are automatically used when beneficial. No special
command-line options are required, but you can:

- Clear cache: Delete ``~/.lfsr-seq/cache.json``
- Monitor performance: Use ``--verbose`` to see which optimizations are used

Python API Usage
-----------------

.. code-block:: python

   from lfsr.polynomial import (
       compute_period_via_factorization,
       detect_mathematical_shortcuts
   )
   from lfsr.optimization import ResultCache, get_global_cache
   
   # Period computation via factorization
   period = compute_period_via_factorization([1, 0, 0, 1], 2)
   print(f"Period: {period}")
   
   # Shortcut detection
   shortcuts = detect_mathematical_shortcuts([1, 0, 0, 1], 2)
   print(f"Primitive: {shortcuts['is_primitive']}")
   print(f"Recommended: {shortcuts['recommended_method']}")
   
   # Caching
   cache = get_global_cache()
   key = cache.generate_key([1, 0, 0, 1], 2, "period")
   
   if key in cache:
       period = cache.get(key)
   else:
       period = compute_period_via_factorization([1, 0, 0, 1], 2)
       cache.set(key, period)
   
   # Cache statistics
   stats = cache.get_stats()
   print(f"Hit rate: {stats['hit_rate']:.2%}")

Glossary
--------

**Cache**
   A storage mechanism for computed results to avoid redundant calculations.

**Cache Hit**
   When a requested result is found in the cache, avoiding recomputation.

**Cache Key**
   A unique identifier for a computation, generated from the LFSR configuration.

**Cache Miss**
   When a requested result is not in the cache, requiring computation.

**Factorization**
   Decomposing a polynomial into irreducible factors.

**Irreducible Factor**
   A polynomial that cannot be factored further over the given field.

**LCM (Least Common Multiple)**
   The smallest positive integer divisible by all given integers.

**Mathematical Shortcut**
   An optimized algorithm for a special case that avoids expensive computation.

**Order of a Polynomial**
   The smallest positive integer n such that t^n ≡ 1 (mod P(t)).

**Persistent Cache**
   A cache that survives between program runs, stored on disk.

**Polynomial Factorization**
   The process of decomposing a polynomial into irreducible factors.

**Primitive Polynomial**
   An irreducible polynomial whose order is q^d - 1 (maximum period).

**Result Caching**
   Storing computed results for reuse without recomputation.

Further Reading
---------------

- SageMath Documentation: Polynomial Factorization
- Menezes, A. J., et al. (1996). "Handbook of Applied Cryptography"
- Lidl, R., & Niederreiter, H. (1997). "Finite Fields"
