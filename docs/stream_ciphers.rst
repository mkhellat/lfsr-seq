Stream Cipher Analysis
======================

This section provides a comprehensive guide to stream cipher analysis, focusing
on real-world stream ciphers that use LFSRs. The documentation is designed to be
accessible to beginners while providing sufficient depth for researchers and
developers.

Introduction
------------

**What is a Stream Cipher?**

A **stream cipher** is a symmetric encryption algorithm that encrypts data one
bit (or byte) at a time, typically by XORing the plaintext with a pseudorandom
keystream. Stream ciphers are widely used in applications requiring high-speed
encryption, such as wireless communications, disk encryption, and network protocols.

**Key Characteristics**:

- **Symmetric**: Same key is used for encryption and decryption
- **Streaming**: Processes data incrementally (one bit/byte at a time)
- **Keystream**: Pseudorandom sequence generated from secret key
- **XOR Operation**: Plaintext is XORed with keystream to produce ciphertext

**Why Analyze Stream Ciphers?**

1. **Real-World Relevance**: Many deployed systems use stream ciphers
2. **Educational Value**: Understanding practical applications of LFSRs
3. **Security Analysis**: Assessing cipher security and vulnerabilities
4. **Research**: Comparing designs and identifying weaknesses

**Stream Ciphers Covered**:

This documentation covers analysis of the following stream ciphers:

- **A5/1**: GSM mobile phone encryption (3 LFSRs, irregular clocking)
- **A5/2**: Weaker GSM variant (4 LFSRs)
- **E0**: Bluetooth encryption (4 LFSRs, non-linear combiner)
- **Trivium**: eSTREAM finalist (3 shift registers, non-linear feedback)
- **Grain Family**: Grain-128, Grain-128a (LFSR + NFSR)
- **LILI-128**: Academic design (2 LFSRs, clock control)

Key Concepts
------------

Stream Cipher Fundamentals
~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Keystream Generation**:

The keystream is generated from:
- **Secret Key**: A secret value known only to sender and receiver
- **Initialization Vector (IV)**: A non-secret value that varies per message
- **State**: Internal state of the cipher (LFSRs, memory, etc.)

The keystream generation process:
1. Initialize cipher state with key and IV
2. Run warm-up phase (optional, discards initial output)
3. Generate keystream bits by evolving state

**Encryption Process**:

.. math::

   C_i = P_i \\oplus K_i

where:
- C_i is ciphertext bit i
- P_i is plaintext bit i
- K_i is keystream bit i
- ⊕ is XOR operation

**Decryption Process**:

Decryption is identical to encryption (XOR is its own inverse):

.. math::

   P_i = C_i \\oplus K_i

**Key Terminology**:

- **Keystream**: Pseudorandom sequence of bits generated by the cipher
- **Key**: Secret value used to initialize the cipher (typically 80-256 bits)
- **Initialization Vector (IV)**: Non-secret value ensuring different keystreams
  for same key (also called "nonce" or "frame number")
- **State**: Internal state of the cipher (LFSR states, memory elements, etc.)
- **Warm-up Phase**: Initial steps where output is discarded (removes
  initialization artifacts)
- **Encryption**: Process of converting plaintext to ciphertext using keystream
- **Decryption**: Process of converting ciphertext back to plaintext
- **XOR (Exclusive OR)**: Binary operation where 0⊕0=0, 0⊕1=1, 1⊕0=1, 1⊕1=0

LFSR-Based Stream Ciphers
~~~~~~~~~~~~~~~~~~~~~~~~~~

Many stream ciphers use LFSRs as building blocks because:
- LFSRs are fast in hardware
- LFSRs have good statistical properties
- LFSR theory is well-understood

**Common Design Patterns**:

1. **Multiple LFSRs**: Combine several LFSRs for increased complexity
2. **Irregular Clocking**: LFSRs don't always advance (clock control)
3. **Non-Linear Combining**: Use non-linear functions instead of simple XOR
4. **Filter Functions**: Apply non-linear functions to LFSR state
5. **Non-Linear Feedback**: Use non-linear feedback instead of linear

**Key Terminology**:

- **LFSR-Based Cipher**: Stream cipher using LFSRs as core components
- **Multiple LFSRs**: Using several LFSRs in parallel for increased security
- **Irregular Clocking**: LFSRs advance conditionally (not every step)
- **Clock Control**: Mechanism determining when LFSRs advance
- **Non-Linear Combining**: Using non-linear functions to combine LFSR outputs
- **Filter Function**: Non-linear function applied to LFSR state
- **Non-Linear Feedback**: Feedback function is not linear (generalizes LFSR)

A5/1 Cipher
-----------

**Overview**:

A5/1 is a stream cipher that was used for GSM (Global System for Mobile
Communications) mobile phone encryption. It was designed in 1987 and became the
standard encryption algorithm for GSM voice and data communications.

**Historical Context**:

- **Designed**: 1987
- **Purpose**: GSM mobile phone encryption
- **Status**: Widely deployed, now considered insecure
- **Replacement**: A5/3 (KASUMI) and A5/4 (SNOW 3G) for 3G/4G

**Cipher Structure**:

A5/1 uses three LFSRs with irregular clocking:

- **LFSR1**: 19 bits
  - Feedback polynomial: x^19 + x^18 + x^17 + x^14 + 1
  - Taps at positions: 18, 17, 16, 13
- **LFSR2**: 22 bits
  - Feedback polynomial: x^22 + x^21 + 1
  - Taps at positions: 21, 20
- **LFSR3**: 23 bits
  - Feedback polynomial: x^23 + x^22 + x^21 + x^8 + 1
  - Taps at positions: 22, 21, 20, 7

**Clock Control**:

The clocking is controlled by a majority function:
- Clock control bits: LFSR1[8], LFSR2[10], LFSR3[10]
- Majority function: Outputs the majority value (0 or 1) of the three bits
- Clocking rule: An LFSR advances if its clock control bit matches the majority

**Output**:

The keystream is the XOR of the three LFSR output bits (MSB of each LFSR).

**Key and IV**:

- **Key Size**: 64 bits
- **IV Size**: 22 bits (frame number in GSM)
- **Total State**: 64 bits (19 + 22 + 23)

**Initialization**:

1. Load 64-bit key into LFSRs (19 + 22 + 23 bits)
2. Load 22-bit frame number (IV) into LFSRs
3. Run 100 warm-up steps (discard output)
4. Generate keystream

**Security Status**:

A5/1 has been extensively cryptanalyzed and is now considered insecure. Known
attacks include:

- **Time-Memory Trade-Off Attacks**: Barkan, Biham, Keller (2003) - can recover
  key in seconds with precomputed tables
- **Correlation Attacks**: Exploit correlations between keystream and LFSR sequences
- **Known-Plaintext Attacks**: Recover key from known plaintext-ciphertext pairs
- **Hardware-Based Attacks**: Side-channel and fault injection attacks

**Key Terminology**:

- **A5/1**: The stream cipher used in GSM encryption
- **GSM**: Global System for Mobile Communications, the standard for mobile phones
- **Irregular Clocking**: LFSRs don't always advance on each step
- **Majority Function**: Function that outputs the majority value of its inputs
- **Clock Control Bit**: Bit from each LFSR used to determine clocking
- **Frame Number**: The 22-bit IV used in GSM (represents frame number)
- **Warm-up Phase**: Initial 100 steps before keystream generation (discarded)

**Mathematical Foundation**:

The majority function for three bits a, b, c is:

.. math::

   \\text{majority}(a, b, c) = (a \\land b) \\lor (a \\land c) \\lor (b \\land c)

where ∧ is AND and ∨ is OR.

The keystream output is:

.. math::

   K_i = L_1[i] \\oplus L_2[i] \\oplus L_3[i]

where L_j[i] is the output bit (MSB) of LFSR j at step i.

**Algorithm**:

1. **Initialization**:
   - Load key bits into LFSRs
   - Load frame number (IV) into LFSRs
   - Run 100 warm-up steps

2. **Keystream Generation** (for each output bit):
   - Get clock control bits: c1 = LFSR1[8], c2 = LFSR2[10], c3 = LFSR3[10]
   - Compute majority: m = majority(c1, c2, c3)
   - Clock LFSRs: Advance LFSR j if c_j == m
   - Output: XOR of three LFSR output bits

API Reference
-------------

The stream cipher analysis is implemented in the :mod:`lfsr.ciphers` module.
See :doc:`api/ciphers` for complete API documentation.

Command-Line Usage
------------------

Stream cipher analysis can be performed from the command line:

**Basic Usage**:

.. code-block:: bash

   lfsr-seq --cipher a5_1 --analyze-cipher

**Generate Keystream**:

.. code-block:: bash

   lfsr-seq --cipher a5_1 --generate-keystream --key-file key.bin --length 1000

**Apply Attacks**:

.. code-block:: bash

   lfsr-seq --cipher a5_1 --attack-cipher --keystream-file keystream.bin

**CLI Options**:
- ``--cipher NAME``: Select cipher (a5_1, a5_2, e0, trivium, grain, lili128)
- ``--analyze-cipher``: Analyze cipher structure
- ``--generate-keystream``: Generate keystream from key and IV
- ``--attack-cipher``: Apply attacks to keystream
- ``--compare-ciphers``: Compare multiple ciphers

Python API Usage
----------------

Here's a simple example demonstrating A5/1 analysis using the Python API:

.. code-block:: python

   from lfsr.ciphers.a5_1 import A5_1
   
   # Create A5/1 cipher instance
   cipher = A5_1()
   
   # Get cipher configuration
   config = cipher.get_config()
   print(f"Cipher: {config.cipher_name}")
   print(f"Key size: {config.key_size} bits")
   print(f"IV size: {config.iv_size} bits")
   
   # Analyze structure
   structure = cipher.analyze_structure()
   print(f"Number of LFSRs: {len(structure.lfsr_configs)}")
   print(f"Total state size: {structure.state_size} bits")
   
   # Generate keystream
   key = [1, 0, 1] * 21 + [1]  # 64-bit key
   iv = [0] * 22  # 22-bit IV (frame number)
   keystream = cipher.generate_keystream(key, iv, 100)
   print(f"Generated {len(keystream)} keystream bits")
   
   # Comprehensive analysis
   result = cipher.analyze(key=key, iv=iv, keystream_length=1000)
   print(f"Keystream balance: {result.keystream_properties['balance']:.4f}")

Glossary
--------

**A5/1**
   Stream cipher used in GSM mobile phone encryption.

**Clock Control**
   Mechanism determining when LFSRs advance in irregular clocking.

**Clock Control Bit**
   Bit from each LFSR used to determine clocking behavior.

**Decryption**
   Process of converting ciphertext back to plaintext.

**Encryption**
   Process of converting plaintext to ciphertext using keystream.

**Frame Number**
   The 22-bit IV used in GSM (represents frame number).

**Initialization Vector (IV)**
   Non-secret value ensuring different keystreams for same key.

**Irregular Clocking**
   LFSRs don't always advance on each step (clock control).

**Keystream**
   Pseudorandom sequence of bits generated by the cipher.

**Key**
   Secret value used to initialize the cipher.

**Majority Function**
   Function that outputs the majority value of its inputs.

**State**
   Internal state of the cipher (LFSR states, memory elements, etc.).

**Stream Cipher**
   Symmetric encryption algorithm that encrypts data one bit at a time.

**Warm-up Phase**
   Initial steps where output is discarded (removes initialization artifacts).

**XOR (Exclusive OR)**
   Binary operation where 0⊕0=0, 0⊕1=1, 1⊕0=1, 1⊕1=0.

Further Reading
---------------

- Barkan, E., Biham, E., & Keller, N. (2003). "Instant Ciphertext-Only Cryptanalysis
  of GSM Encrypted Communication"

- Biryukov, A., Shamir, A., & Wagner, D. (2000). "Real Time Cryptanalysis of A5/1
  on a PC"

- Golic, J. D. (1997). "Cryptanalysis of Alleged A5 Stream Cipher"

- Menezes, A. J., et al. (1996). "Handbook of Applied Cryptography"

- GSM Association. "GSM Security Algorithms"
