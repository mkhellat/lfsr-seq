#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Multi-Output LFSR Analysis

This module provides analysis capabilities for multi-output LFSRs, which are
LFSRs that produce multiple output bits per step, rather than a single bit.

**Historical Context**:

Multi-output LFSRs were developed to increase the output rate of LFSR-based
generators. By outputting multiple bits per step, the generator can produce
keystream faster, which is important for high-speed applications. Multi-output
LFSRs are used in various stream cipher designs.

**Key Terminology**:

- **Multi-Output LFSR**: An LFSR that produces multiple output bits per step,
  rather than a single bit. This increases the output rate and can improve
  efficiency.

- **Output Function**: A function that maps the LFSR state to multiple output
  bits. The output function can be linear (selecting multiple state bits) or
  non-linear (combining state bits).

- **Output Rate**: The number of bits output per clock step. A standard LFSR
  has output rate 1, while a multi-output LFSR has output rate > 1.

- **Parallel Output**: Multiple bits output simultaneously from the same state.
  This is different from running the LFSR multiple times.

- **Output Selection**: Choosing which state bits to output. Can be fixed
  positions or determined by a function.

**Mathematical Foundation**:

A multi-output LFSR of degree d with output rate r has:
- State: S_t = (s_0, s_1, ..., s_{d-1})
- Output function: f: GF(q)^d â†’ GF(q)^r
- Output: (z_0, z_1, ..., z_{r-1}) = f(S_t)

The state updates once per step, but r bits are output.
"""

from typing import List, Callable, Optional

from sage.all import *

from lfsr.attacks import LFSRConfig
from lfsr.advanced.base import (
    AdvancedLFSR,
    AdvancedLFSRConfig
)
from lfsr.core import build_state_update_matrix


class MultiOutputLFSR(AdvancedLFSR):
    """
    Multi-output LFSR implementation.
    
    A multi-output LFSR produces multiple output bits per step, increasing
    the output rate compared to standard LFSRs.
    
    **Key Terminology**:
    
    - **Multi-Output LFSR**: LFSR producing multiple bits per step
    
    - **Output Rate**: Number of bits output per clock step
    
    - **Output Function**: Function mapping state to multiple output bits
    
    **Cipher Structure**:
    
    A multi-output LFSR has:
    - Base LFSR: Standard LFSR structure
    - Output function: Maps state to r output bits
    - Output rate: r bits per step
    
    **Example Usage**:
    
        >>> from lfsr.advanced.multi_output import MultiOutputLFSR
        >>> from lfsr.attacks import LFSRConfig
        >>> 
        >>> base_config = LFSRConfig(coefficients=[1, 0, 0, 1], field_order=2, degree=4)
        >>> 
        >>> # Define output function (output first 2 state bits)
        >>> def output_func(state):
        ...     return [state[0], state[1]]  # Output 2 bits
        >>> 
        >>> molfsr = MultiOutputLFSR(base_config, output_func, output_rate=2)
        >>> sequence = molfsr.generate_sequence([1, 0, 1, 1], 100)
    """
    
    def __init__(
        self,
        base_lfsr_config: LFSRConfig,
        output_function: Callable[[List[int]], List[int]],
        output_rate: int = 2
    ):
        """
        Initialize multi-output LFSR.
        
        Args:
            base_lfsr_config: Base LFSR configuration
            output_function: Function mapping state to list of output bits
            output_rate: Number of bits output per step (default: 2)
        """
        self.base_lfsr_config = base_lfsr_config
        self.output_function = output_function
        self.output_rate = output_rate
        self.degree = base_lfsr_config.degree
        self.field_order = base_lfsr_config.field_order
        
        # Build state update matrix
        self.C, self.CS = build_state_update_matrix(
            base_lfsr_config.coefficients,
            self.field_order
        )
    
    def get_config(self) -> AdvancedLFSRConfig:
        """Get multi-output LFSR configuration."""
        return AdvancedLFSRConfig(
            structure_type="multi_output",
            base_lfsr_config=self.base_lfsr_config,
            parameters={
                'degree': self.degree,
                'field_order': self.field_order,
                'output_rate': self.output_rate
            }
        )
    
    def generate_sequence(
        self,
        initial_state: List[int],
        length: int
    ) -> List[int]:
        """
        Generate sequence from initial state.
        
        The sequence is generated by:
        1. Applying output function to current state (produces r bits)
        2. Updating LFSR state
        3. Repeating
        
        Note: length is the number of output bits, not the number of steps.
        Number of steps = length / output_rate.
        
        Args:
            initial_state: Initial state as list of field elements
            length: Desired sequence length (in bits)
        
        Returns:
            List of sequence elements (flattened output)
        """
        if len(initial_state) != self.degree:
            raise ValueError(
                f"Initial state must have length {self.degree}, got {len(initial_state)}"
            )
        
        F = GF(self.field_order)
        state_vec = vector(F, initial_state)
        sequence = []
        
        steps_needed = (length + self.output_rate - 1) // self.output_rate
        
        for _ in range(steps_needed):
            # Apply output function to current state
            state_list = [int(x) for x in state_vec]
            output_bits = self.output_function(state_list)
            
            # Add output bits to sequence
            sequence.extend(output_bits[:self.output_rate])
            
            # Update state
            state_vec = self.C * state_vec
        
        # Return only requested length
        return sequence[:length]
    
    def analyze_structure(self) -> dict:
        """
        Analyze multi-output LFSR structure properties.
        
        This method analyzes the base LFSR, output function, and output
        rate properties.
        
        Returns:
            Dictionary of structure properties
        """
        # Analyze base LFSR
        base_properties = {
            'degree': self.degree,
            'field_order': self.field_order,
            'coefficients': self.base_lfsr_config.coefficients
        }
        
        # Analyze output function
        output_properties = {
            'output_rate': self.output_rate,
            'output_type': 'multi-bit'
        }
        
        return {
            'structure_type': 'multi-output LFSR',
            'base_lfsr': base_properties,
            'output': output_properties,
            'efficiency': {
                'bits_per_step': self.output_rate,
                'speedup': self.output_rate  # Compared to single-output
            }
        }
