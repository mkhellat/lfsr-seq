#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Correlation Attack Framework for LFSR-based stream ciphers.

This module implements correlation attacks, which are fundamental cryptanalytic
techniques used to attack combination generators. A combination generator combines
multiple LFSRs using a non-linear function, and correlation attacks exploit
statistical correlations between the output and individual LFSR outputs.

Key Concepts:
-------------

**Combination Generator**: A stream cipher design where multiple LFSRs are combined
using a non-linear function (e.g., majority, XOR, AND). The output is the result
of applying this function to the LFSR outputs.

**Correlation Attack**: A cryptanalytic technique that exploits statistical
correlations between the keystream (observed output) and the output of individual
LFSRs. If such correlations exist, an attacker can recover the state of individual
LFSRs by analyzing the keystream.

**Correlation Coefficient**: A measure of linear relationship between two sequences,
ranging from -1 (perfect negative correlation) to +1 (perfect positive correlation).
A value near 0 indicates no correlation.

**Siegenthaler's Attack**: The fundamental correlation attack, named after its
inventor. It works by measuring the correlation between the keystream and sequences
generated by individual LFSRs.

Example:
--------

    >>> from lfsr.attacks import (
    ...     CombinationGenerator,
    ...     siegenthaler_correlation_attack,
    ...     compute_correlation_coefficient
    ... )
    >>> from lfsr.core import build_state_update_matrix
    >>> from sage.all import *
    >>>
    >>> # Create a combination generator with 3 LFSRs
    >>> lfsr1 = {'coefficients': [1, 0, 0, 1], 'field_order': 2, 'degree': 4}
    >>> lfsr2 = {'coefficients': [1, 1, 0, 1], 'field_order': 2, 'degree': 4}
    >>> lfsr3 = {'coefficients': [1, 0, 1, 1], 'field_order': 2, 'degree': 4}
    >>>
    >>> # Define majority function as combining function
    >>> def majority(a, b, c):
    ...     return 1 if (a + b + c) >= 2 else 0
    >>>
    >>> gen = CombinationGenerator(
    ...     lfsrs=[lfsr1, lfsr2, lfsr3],
    ...     combining_function=majority,
    ...     function_name='majority'
    ... )
    >>>
    >>> # Generate keystream
    >>> keystream = gen.generate_keystream(length=1000)
    >>>
    >>> # Attack LFSR1
    >>> result = siegenthaler_correlation_attack(
    ...     combination_generator=gen,
    ...     keystream=keystream,
    ...     target_lfsr_index=0
    ... )
    >>>
    >>> print(f"Correlation: {result['correlation_coefficient']:.4f}")
    >>> print(f"Attack successful: {result['attack_successful']}")
"""

import math
from collections import Counter
from dataclasses import dataclass, field
from typing import Callable, Dict, List, Optional, Tuple, Any

try:
    from scipy.stats import norm
    SCIPY_AVAILABLE = True
except ImportError:
    SCIPY_AVAILABLE = False
    # Fallback: simple normal approximation using class to match scipy interface
    class _NormFallback:
        """Fallback normal distribution functions when scipy is not available."""
        @staticmethod
        def ppf(p):
            """Simple approximation of normal quantile function."""
            import math
            if p < 0.5:
                return -math.sqrt(2) * math.erfinv(2 * p)
            else:
                return math.sqrt(2) * math.erfinv(2 * (1 - p))
        
        @staticmethod
        def cdf(x):
            """Simple approximation of normal CDF."""
            import math
            return 0.5 * (1 + math.erf(x / math.sqrt(2)))
    
    norm = _NormFallback()

from sage.all import *


@dataclass
class LFSRConfig:
    """
    Configuration for a single LFSR in a combination generator.
    
    Attributes:
        coefficients: List of feedback polynomial coefficients [c_0, c_1, ..., c_{d-1}]
        field_order: Field order (q) - typically 2 for binary
        degree: Degree of the LFSR (length of state vector)
        initial_state: Optional initial state vector (defaults to [1, 0, ..., 0])
    
    Example:
        >>> lfsr = LFSRConfig(
        ...     coefficients=[1, 0, 0, 1],
        ...     field_order=2,
        ...     degree=4
        ... )
    """
    coefficients: List[int]
    field_order: int
    degree: int
    initial_state: Optional[List[int]] = None


@dataclass
class CombinationGenerator:
    """
    Represents a combination generator with multiple LFSRs.
    
    A combination generator combines the outputs of multiple LFSRs using a
    non-linear function. This is a common design pattern in stream ciphers.
    
    Attributes:
        lfsrs: List of LFSR configurations
        combining_function: Function that takes LFSR outputs and returns keystream bit
        function_name: Human-readable name of the combining function
    
    Example:
        >>> def xor_combiner(a, b):
        ...     return a ^ b
        >>> 
        >>> gen = CombinationGenerator(
        ...     lfsrs=[
        ...         LFSRConfig([1, 0, 0, 1], 2, 4),
        ...         LFSRConfig([1, 1, 0, 1], 2, 4)
        ...     ],
        ...     combining_function=xor_combiner,
        ...     function_name='xor'
        ... )
    """
    lfsrs: List[LFSRConfig]
    combining_function: Callable
    function_name: str
    
    def generate_keystream(self, length: int, initial_states: Optional[List[List[int]]] = None) -> List[int]:
        """
        Generate keystream from the combination generator.
        
        Args:
            length: Number of keystream bits to generate
            initial_states: Optional list of initial states for each LFSR
        
        Returns:
            List of keystream bits
        """
        from lfsr.core import build_state_update_matrix
        
        # Initialize LFSR states
        states = []
        matrices = []
        
        for idx, lfsr_config in enumerate(self.lfsrs):
            C, CS = build_state_update_matrix(lfsr_config.coefficients, lfsr_config.field_order)
            matrices.append((C, CS))
            
            if initial_states and idx < len(initial_states):
                state = vector(GF(lfsr_config.field_order), initial_states[idx])
            elif lfsr_config.initial_state:
                state = vector(GF(lfsr_config.field_order), lfsr_config.initial_state)
            else:
                # Default: [1, 0, 0, ..., 0]
                state = vector(GF(lfsr_config.field_order), [1] + [0] * (lfsr_config.degree - 1))
            
            states.append(state)
        
        # Generate keystream
        keystream = []
        for _ in range(length):
            # Get outputs from each LFSR
            outputs = []
            for idx, (state, (C, CS)) in enumerate(zip(states, matrices)):
                # Output is first element of state
                output = int(state[0])
                outputs.append(output)
                
                # Update state
                states[idx] = C * state
            
            # Combine outputs using combining function
            keystream_bit = self.combining_function(*outputs)
            keystream.append(keystream_bit)
        
        return keystream
    
    def generate_lfsr_sequence(self, lfsr_index: int, length: int, initial_state: Optional[List[int]] = None) -> List[int]:
        """
        Generate sequence from a single LFSR (for correlation analysis).
        
        Args:
            lfsr_index: Index of LFSR to generate sequence from
            length: Length of sequence to generate
            initial_state: Optional initial state
        
        Returns:
            List of output bits from the specified LFSR
        """
        from lfsr.core import build_state_update_matrix
        
        lfsr_config = self.lfsrs[lfsr_index]
        C, CS = build_state_update_matrix(lfsr_config.coefficients, lfsr_config.field_order)
        
        if initial_state:
            state = vector(GF(lfsr_config.field_order), initial_state)
        elif lfsr_config.initial_state:
            state = vector(GF(lfsr_config.field_order), lfsr_config.initial_state)
        else:
            state = vector(GF(lfsr_config.field_order), [1] + [0] * (lfsr_config.degree - 1))
        
        sequence = []
        for _ in range(length):
            output = int(state[0])
            sequence.append(output)
            state = C * state
        
        return sequence


@dataclass
class CorrelationAttackResult:
    """
    Results from a correlation attack.
    
    Attributes:
        target_lfsr_index: Index of the LFSR that was attacked
        correlation_coefficient: Measured correlation coefficient (range: -1 to +1)
        p_value: Statistical significance (probability that correlation is due to chance)
        attack_successful: Whether the attack succeeded (correlation is significant)
        success_probability: Estimated probability that the attack will succeed
        required_keystream_bits: Estimated number of keystream bits needed for attack
        complexity_estimate: Estimated computational complexity of full attack
        matches: Number of matching bits between keystream and LFSR sequence
        total_bits: Total number of bits compared
        match_ratio: Ratio of matches to total bits
    """
    target_lfsr_index: int
    correlation_coefficient: float
    p_value: float
    attack_successful: bool
    success_probability: float
    required_keystream_bits: int
    complexity_estimate: float
    matches: int
    total_bits: int
    match_ratio: float


def compute_correlation_coefficient(
    sequence1: List[int],
    sequence2: List[int]
) -> Tuple[float, float, Dict[str, Any]]:
    """
    Compute correlation coefficient between two binary sequences.
    
    The correlation coefficient measures the linear relationship between two
    sequences. For binary sequences, it's computed as:
    
    ρ = 2·Pr[X = Y] - 1
    
    where Pr[X = Y] is the probability that corresponding bits match.
    
    A correlation coefficient of:
    - +1: Perfect positive correlation (sequences identical)
    - 0: No correlation (sequences independent)
    - -1: Perfect negative correlation (sequences are complements)
    
    Args:
        sequence1: First binary sequence
        sequence2: Second binary sequence (must be same length)
    
    Returns:
        Tuple of (correlation_coefficient, p_value, detailed_stats)
        - correlation_coefficient: Value between -1 and +1
        - p_value: Statistical significance (two-tailed test)
        - detailed_stats: Dictionary with match count, match ratio, etc.
    
    Raises:
        ValueError: If sequences have different lengths
    
    Example:
        >>> seq1 = [1, 0, 1, 0, 1]
        >>> seq2 = [1, 1, 1, 0, 0]
        >>> rho, p, stats = compute_correlation_coefficient(seq1, seq2)
        >>> print(f"Correlation: {rho:.3f}, p-value: {p:.3f}")
    """
    if len(sequence1) != len(sequence2):
        raise ValueError(f"Sequences must have same length: {len(sequence1)} != {len(sequence2)}")
    
    n = len(sequence1)
    if n == 0:
        return 0.0, 1.0, {"error": "Empty sequences"}
    
    # Count matches (bits that are equal)
    matches = sum(1 for a, b in zip(sequence1, sequence2) if a == b)
    match_ratio = matches / n
    
    # Correlation coefficient: ρ = 2·Pr[match] - 1
    correlation = 2.0 * match_ratio - 1.0
    
    # Statistical significance test (two-tailed binomial test)
    # Under null hypothesis (no correlation), Pr[match] = 0.5
    # We test if observed match_ratio is significantly different from 0.5
    
    # For large n, use normal approximation
    if n > 30:
        # Z-score
        expected_matches = n * 0.5
        variance = n * 0.5 * 0.5
        std_dev = math.sqrt(variance)
        z_score = (matches - expected_matches) / std_dev if std_dev > 0 else 0.0
        
        # Two-tailed p-value (approximate using normal distribution)
        # For exact calculation, we'd use binomial distribution
        # Using approximation: p ≈ 2 * (1 - Φ(|z|))
        # For simplicity, we use a rough approximation
        p_value = 2.0 * (1.0 - 0.5 * (1.0 + math.erf(abs(z_score) / math.sqrt(2))))
        p_value = max(0.0, min(1.0, p_value))  # Clamp to [0, 1]
    else:
        # For small n, use exact binomial test (simplified)
        # This is a rough approximation - for exact results, use scipy.stats.binom_test
        p_value = 0.5  # Placeholder - would need exact binomial computation
    
    detailed_stats = {
        "matches": matches,
        "mismatches": n - matches,
        "total_bits": n,
        "match_ratio": match_ratio,
        "expected_match_ratio": 0.5,
        "deviation": abs(match_ratio - 0.5),
    }
    
    return correlation, p_value, detailed_stats


def estimate_attack_success_probability(
    correlation_coefficient: float,
    keystream_length: int,
    lfsr_degree: int,
    field_order: int = 2,
    significance_level: float = 0.05,
    target_success_probability: float = 0.95
) -> Dict[str, Any]:
    """
    Estimate the probability that a correlation attack will succeed.
    
    The attack success probability depends on:
    1. **Detection Probability**: Probability of detecting the correlation
       (statistical power)
    2. **Recovery Probability**: Probability of recovering the LFSR state
       (computational feasibility)
    
    The overall success probability is the product of these two factors.
    
    **Detection Probability**:
    The probability of detecting a correlation depends on:
    - The correlation coefficient strength (|ρ|)
    - The amount of keystream available (n)
    - The statistical significance level (α)
    
    For a given correlation coefficient ρ and keystream length n, the detection
    probability increases with n and |ρ|. Using normal approximation:
    
    .. math::
    
       P_{\\text{detect}} = 1 - \\Phi\\left(\\frac{z_{\\alpha/2} - |\\rho|\\sqrt{n}}{\\sqrt{1-\\rho^2}}\\right)
    
    where :math:`z_{\\alpha/2}` is the critical value for significance level α.
    
    **Recovery Probability**:
    The probability of recovering the state depends on:
    - The state space size (:math:`q^d`)
    - Whether the correlation is strong enough to distinguish the correct state
    
    For correlation attacks, recovery is typically feasible if:
    - The state space is not too large (< 2^40 for practical attacks)
    - The correlation is significant (|ρ| > threshold)
    
    Args:
        correlation_coefficient: Measured correlation coefficient (-1 to +1)
        keystream_length: Number of keystream bits available
        lfsr_degree: Degree of the target LFSR
        field_order: Field order (default: 2 for binary)
        significance_level: Statistical significance level (default: 0.05)
        target_success_probability: Target success probability for estimation
            (default: 0.95)
    
    Returns:
        Dictionary with:
        - 'detection_probability': Probability of detecting correlation
        - 'recovery_probability': Probability of recovering state
        - 'overall_success_probability': Overall attack success probability
        - 'required_keystream_bits': Estimated keystream bits needed for target
          success probability
        - 'feasible': Whether attack is computationally feasible
    
    Example:
        >>> result = estimate_attack_success_probability(
        ...     correlation_coefficient=0.3,
        ...     keystream_length=1000,
        ...     lfsr_degree=10,
        ...     field_order=2
        ... )
        >>> print(f"Success probability: {result['overall_success_probability']:.2%}")
    """
    abs_correlation = abs(correlation_coefficient)
    
    # State space size
    state_space_size = field_order ** lfsr_degree
    
    # Detection probability using normal approximation
    # For binary sequences, under null hypothesis: E[matches] = n/2, Var = n/4
    # Under alternative: E[matches] = n * (1 + ρ)/2, Var ≈ n/4
    
    if abs_correlation == 0 or keystream_length == 0:
        detection_prob = 0.0
    else:
        # Z-score for significance level (two-tailed)
        z_critical = abs(norm.ppf(significance_level / 2))
        
        # Effect size: correlation coefficient
        # Standard error under null hypothesis
        se_null = 1.0 / math.sqrt(keystream_length)
        
        # Z-score for observed correlation
        z_observed = abs_correlation / se_null
        
        # Detection probability: probability that z_observed > z_critical
        # Using normal approximation
        detection_prob = 1.0 - norm.cdf(z_critical - z_observed)
        detection_prob = max(0.0, min(1.0, detection_prob))  # Clamp to [0, 1]
    
    # Recovery probability
    # For correlation attacks, recovery is feasible if:
    # 1. State space is not too large
    # 2. Correlation is strong enough
    
    # Rough feasibility threshold: state space < 2^40
    max_feasible_state_space = 2 ** 40
    
    if state_space_size > max_feasible_state_space:
        recovery_prob = 0.0
        feasible = False
    elif abs_correlation < 0.01:  # Very weak correlation
        recovery_prob = 0.0
        feasible = False
    elif abs_correlation < 0.1:  # Weak correlation
        recovery_prob = 0.1  # Low probability even if detectable
        feasible = True
    elif abs_correlation < 0.3:  # Moderate correlation
        recovery_prob = 0.5  # Moderate probability
        feasible = True
    else:  # Strong correlation
        recovery_prob = 0.9  # High probability
        feasible = True
    
    # Overall success probability
    overall_success_prob = detection_prob * recovery_prob
    
    # Estimate required keystream bits for target success probability
    # Using approximation: n ≈ (z_α/2 / |ρ|)^2 for detection
    if abs_correlation > 0:
        # For target detection probability, we need:
        # P_detect = 1 - Φ(z_critical - |ρ|√n / se)
        # Solving for n:
        if SCIPY_AVAILABLE:
            z_target = abs(norm.ppf((1 - target_success_probability) / 2))
        else:
            z_target = abs(norm_ppf((1 - target_success_probability) / 2))
        required_bits = int((z_target / abs_correlation) ** 2) if abs_correlation > 0.001 else 1000000
    else:
        required_bits = 1000000  # Very large if no correlation
    
    return {
        'detection_probability': detection_prob,
        'recovery_probability': recovery_prob,
        'overall_success_probability': overall_success_prob,
        'required_keystream_bits': required_bits,
        'feasible': feasible,
        'state_space_size': state_space_size
    }


def siegenthaler_correlation_attack(
    combination_generator: CombinationGenerator,
    keystream: List[int],
    target_lfsr_index: int,
    significance_level: float = 0.05,
    max_sequence_length: int = 10000
) -> CorrelationAttackResult:
    """
    Perform Siegenthaler's basic correlation attack.
    
    Siegenthaler's correlation attack is the fundamental correlation attack
    technique. It works by:
    
    1. Generating a sequence from the target LFSR
    2. Computing the correlation coefficient between this sequence and the keystream
    3. Testing if the correlation is statistically significant
    4. If significant, the attack succeeds and can be used to recover the LFSR state
    
    The attack succeeds when there is a significant correlation (positive or negative)
    between the keystream and the target LFSR sequence. This indicates that the
    combining function leaks information about the LFSR output.
    
    Args:
        combination_generator: The combination generator being attacked
        keystream: Observed keystream bits (output of combination generator)
        target_lfsr_index: Index of LFSR to attack (0-based)
        significance_level: Statistical significance level (default: 0.05)
        max_sequence_length: Maximum length of LFSR sequence to generate
    
    Returns:
        CorrelationAttackResult with attack results
    
    Example:
        >>> from lfsr.attacks import CombinationGenerator, LFSRConfig, siegenthaler_correlation_attack
        >>> 
        >>> def majority(a, b, c):
        ...     return 1 if (a + b + c) >= 2 else 0
        >>> 
        >>> gen = CombinationGenerator(
        ...     lfsrs=[
        ...         LFSRConfig([1, 0, 0, 1], 2, 4),
        ...         LFSRConfig([1, 1, 0, 1], 2, 4),
        ...         LFSRConfig([1, 0, 1, 1], 2, 4)
        ...     ],
        ...     combining_function=majority,
        ...     function_name='majority'
        ... )
        >>> 
        >>> keystream = gen.generate_keystream(1000)
        >>> result = siegenthaler_correlation_attack(gen, keystream, target_lfsr_index=0)
        >>> 
        >>> if result.attack_successful:
        ...     print(f"Attack succeeded! Correlation: {result.correlation_coefficient:.4f}")
    """
    if target_lfsr_index < 0 or target_lfsr_index >= len(combination_generator.lfsrs):
        raise ValueError(f"Invalid LFSR index: {target_lfsr_index}")
    
    n = len(keystream)
    if n == 0:
        raise ValueError("Keystream cannot be empty")
    
    # Generate sequence from target LFSR
    # Try different initial states to find best correlation
    # For now, use default initial state
    lfsr_sequence = combination_generator.generate_lfsr_sequence(
        target_lfsr_index,
        min(n, max_sequence_length)
    )
    
    # Truncate to match keystream length
    if len(lfsr_sequence) > n:
        lfsr_sequence = lfsr_sequence[:n]
    elif len(lfsr_sequence) < n:
        # Extend sequence if needed (shouldn't happen, but handle gracefully)
        lfsr_sequence = lfsr_sequence * ((n // len(lfsr_sequence)) + 1)
        lfsr_sequence = lfsr_sequence[:n]
    
    # Compute correlation
    correlation, p_value, stats = compute_correlation_coefficient(keystream, lfsr_sequence)
    
    # Determine if attack is successful
    # Attack succeeds if correlation is significantly different from 0
    attack_successful = p_value < significance_level and abs(correlation) > 0.1
    
    # Estimate required keystream bits
    # Rough estimate: need enough bits to detect correlation with confidence
    # This is a simplified estimate
    if abs(correlation) > 0:
        # Rough estimate based on correlation strength
        required_bits = int(100 / (correlation ** 2)) if abs(correlation) > 0.01 else 10000
    else:
        required_bits = 10000
    
    # Estimate complexity
    # Complexity is roughly O(2^d) where d is LFSR degree (brute force state recovery)
    lfsr_config = combination_generator.lfsrs[target_lfsr_index]
    state_space_size = lfsr_config.field_order ** lfsr_config.degree
    complexity_estimate = float(state_space_size)
    
    # Estimate attack success probability
    prob_estimate = estimate_attack_success_probability(
        correlation_coefficient=correlation,
        keystream_length=n,
        lfsr_degree=lfsr_config.degree,
        field_order=lfsr_config.field_order,
        significance_level=significance_level
    )
    
    # Use more accurate required bits from probability estimation if available
    if prob_estimate['required_keystream_bits'] < required_bits:
        required_bits = prob_estimate['required_keystream_bits']
    
    return CorrelationAttackResult(
        target_lfsr_index=target_lfsr_index,
        correlation_coefficient=correlation,
        p_value=p_value,
        attack_successful=attack_successful,
        success_probability=prob_estimate['overall_success_probability'],
        required_keystream_bits=required_bits,
        complexity_estimate=complexity_estimate,
        matches=stats["matches"],
        total_bits=stats["total_bits"],
        match_ratio=stats["match_ratio"]
    )


def analyze_combining_function(
    function: Callable,
    num_inputs: int,
    field_order: int = 2
) -> Dict[str, Any]:
    """
    Analyze correlation properties of a combining function.
    
    This function analyzes a combining function to determine its correlation
    immunity and other security properties. A function is correlation immune
    of order m if the output is statistically independent of any m inputs.
    
    Args:
        function: The combining function (takes num_inputs arguments)
        num_inputs: Number of inputs to the function
        field_order: Field order (default: 2 for binary)
    
    Returns:
        Dictionary with analysis results:
        - correlation_immunity: Maximum order of correlation immunity
        - bias: Output bias (deviation from uniform distribution)
        - truth_table: Truth table of the function
        - balanced: Whether function is balanced (equal 0s and 1s)
    
    Example:
        >>> def majority(a, b, c):
        ...     return 1 if (a + b + c) >= 2 else 0
        >>> 
        >>> analysis = analyze_combining_function(majority, num_inputs=3)
        >>> print(f"Correlation immunity: {analysis['correlation_immunity']}")
    """
    # Generate truth table
    truth_table = []
    output_counts = Counter()
    
    # Enumerate all possible inputs
    num_combinations = field_order ** num_inputs
    
    for i in range(num_combinations):
        # Convert i to base-field_order representation
        inputs = []
        temp = i
        for _ in range(num_inputs):
            inputs.append(temp % field_order)
            temp //= field_order
        
        # Evaluate function
        output = function(*inputs)
        truth_table.append((tuple(inputs), output))
        output_counts[output] += 1
    
    # Check if balanced (equal number of 0s and 1s for binary)
    balanced = False
    if field_order == 2:
        balanced = output_counts[0] == output_counts[1]
    
    # Compute bias (deviation from uniform)
    expected_count = num_combinations / field_order
    bias = max(abs(count - expected_count) for count in output_counts.values()) / num_combinations
    
    # Correlation immunity analysis (simplified)
    # For full analysis, would need to check all subsets of inputs
    # This is a simplified version
    correlation_immunity = 0  # Placeholder - full analysis is complex
    
    return {
        "correlation_immunity": correlation_immunity,
        "bias": bias,
        "balanced": balanced,
        "truth_table": truth_table,
        "output_distribution": dict(output_counts),
        "num_inputs": num_inputs,
        "field_order": field_order
    }
