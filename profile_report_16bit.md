# 16-bit LFSR Parallel Execution Profiling Report

**Generated**: 2025-12-29 22:00:03

## Test Configuration

- **State Space Size**: 65,536 states
- **Algorithm**: enumeration
- **Period-Only Mode**: Yes
- **Number of Workers**: 2

## Results Summary

| Metric | Sequential | Parallel | Difference |
|--------|------------|----------|------------|
| **Total Time** | 13.251s | 8.977s | -4.274s (1.48x) |
| **Sequences Found** | 2 | 2 | +0 |
| **Period Sum** | 65536 | 65536 | +0 |

## Sequential Execution Breakdown

- **Total Time**: 13.251s
- **Time per State**: 0.202ms

## Parallel Execution Breakdown

| Stage | Time (s) | % of Total |
|-------|----------|------------|
| Partitioning | 0.231 | 2.6% |
| Prepare Data | 0.000 | 0.0% |
| Wait For Results | 8.720 | 97.1% |
| Pool Creation | 0.024 | 0.3% |
| Submit Tasks | 0.000 | 0.0% |
| Merge Results | 0.000 | 0.0% |

## Overhead Analysis

- **Computation Time** (worker execution): 8.720s (97.1%)
- **Total Overhead**: 0.256s (2.9%)
  - Partitioning: 0.231s
  - Data preparation: 0.000s
  - Pool creation: 0.024s
  - Task submission: 0.000s
  - Result merging: 0.000s

## Performance Analysis

- **Theoretical Speedup** (ideal): 2.0x
- **Theoretical Time** (if perfect parallelization): 6.626s
- **Actual Speedup**: 1.48x
- **Efficiency**: 73.8%

## Bottleneck Identification

**Largest Overhead Stage**: Wait For Results (8.720s, 97.1%)

### âœ… Parallel provides speedup

**Speedup**: 1.48x

## Recommendations

Parallel processing provides benefit for this case.

To improve further:
- Reduce partitioning overhead (currently 0.231s)
- Optimize IPC (currently significant overhead)

---

*Report generated by profile_16bit.py*